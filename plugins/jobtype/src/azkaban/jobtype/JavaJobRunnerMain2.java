/*
 * Copyright 2012 LinkedIn Corp.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package azkaban.jobtype;

import azkaban.jobExecutor.ProcessJob;
import azkaban.utils.JSONUtils;
import azkaban.utils.Props;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.security.UserGroupInformation;
import org.apache.log4j.ConsoleAppender;
import org.apache.log4j.Layout;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.apache.log4j.PatternLayout;

import azkaban.security.commons.HadoopSecurityManager;
import azkaban.security.commons.SecurityUtils;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.security.PrivilegedExceptionAction;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Properties;

public class JavaJobRunnerMain2 {

	public static final String JOB_CLASS = "job.class";
	public static final String DEFAULT_RUN_METHOD = "main";
	public static final String DEFAULT_CANCEL_METHOD = "cancel";

	// This is the Job interface method to get the properties generated by the
	// job.
	public static final String GET_GENERATED_PROPERTIES_METHOD = "getJobGeneratedProperties";

	public static final String CANCEL_METHOD_PARAM = "method.cancel";
	public static final String RUN_METHOD_PARAM = "method.run";
	public static final String[] PROPS_CLASSES = new String[] { "azkaban.utils.Props", "azkaban.common.utils.Props" };

	private static final Layout DEFAULT_LAYOUT = new PatternLayout("%p %m\n");

	public final Logger logger;

	private String _runMethod;
	private String _cancelMethod;
	private String jobName;
	private boolean isFinished = false;
	private final Class<?> runningClass;
	private boolean securityEnabled;
	
	public static void main(String[] args) throws Exception {
		@SuppressWarnings("unused")
		JavaJobRunnerMain2 wrapper = new JavaJobRunnerMain2(args);
	}

	public JavaJobRunnerMain2(String[] args) throws Exception {
		Runtime.getRuntime().addShutdownHook(new Thread() {
			public void run() {
				cancelJob();
			}
		});

		try {
			jobName = System.getenv(ProcessJob.JOB_NAME_ENV);
			String propsFile = System.getenv(ProcessJob.JOB_PROP_ENV);

			logger = Logger.getRootLogger();
			logger.removeAllAppenders();
			ConsoleAppender appender = new ConsoleAppender(DEFAULT_LAYOUT);
			appender.activateOptions();
			logger.addAppender(appender);
			
			Properties prop = new Properties();
			prop.load(new BufferedReader(new FileReader(propsFile)));
			
			final Configuration conf = new Configuration();
			
			UserGroupInformation.setConfiguration(conf);
			securityEnabled = UserGroupInformation.isSecurityEnabled();

			logger.info("Running job " + jobName);
			String className = prop.getProperty(JOB_CLASS);
			if (className == null) {
				throw new Exception("Class name is not set.");
			}
			logger.info("Class name " + className);

			UserGroupInformation proxyUser = null;
			
			// Create the object using proxy
			if (SecurityUtils.shouldProxy(prop)) {
				String userToProxy = prop.getProperty("user.to.proxy");
				if(securityEnabled) {
					logger.setLevel(Level.ERROR);
					proxyUser = SecurityUtils.getProxiedUser(prop, logger, new Configuration());
					logger.setLevel(Level.INFO);
				} else {
					proxyUser = UserGroupInformation.createRemoteUser(userToProxy);
				}
				logger.info("Proxying enabled.");
				logger.info("Proxied as user " + userToProxy);
			}
				
			runningClass = getClass(className);
			
			_cancelMethod = prop.getProperty(CANCEL_METHOD_PARAM, DEFAULT_CANCEL_METHOD);
			_runMethod = prop.getProperty(RUN_METHOD_PARAM, DEFAULT_RUN_METHOD);
			logger.info("Invoking method " + _runMethod + " from " + runningClass.getName());

			if (SecurityUtils.shouldProxy(prop)) {
				logger.info("Proxying enabled.");
				runMethodAsUser(proxyUser, args);
			} else {
				logger.info("Not proxying run.");
				runMethod(args);
			}
			isFinished = true;

			// Get the generated properties and store them to disk, to be read
			// by ProcessJob.
			try {
				final Method generatedPropertiesMethod = runningClass.getMethod(
						GET_GENERATED_PROPERTIES_METHOD, new Class<?>[] {});
				Object outputGendProps = generatedPropertiesMethod.invoke(null, new Object[] {});
				final Method toPropertiesMethod = outputGendProps.getClass().getMethod("toProperties", new Class<?>[] {});
				Properties properties = (Properties)toPropertiesMethod.invoke(outputGendProps, new Object[] {});

				Props outputProps = new Props(null, properties);
				outputGeneratedProperties(outputProps);
			} catch (NoSuchMethodException e) {
				logger.info(String.format(
						"Apparently there isn't a static method[%s], using empty Props object instead.",
						GET_GENERATED_PROPERTIES_METHOD));
				outputGeneratedProperties(new Props());
			}
		}catch (Exception e) {
			isFinished = true;
			throw e;
		}
	}

	private void runMethodAsUser(final UserGroupInformation ugi, final String[] args) throws IOException, InterruptedException {
		ugi.doAs(new PrivilegedExceptionAction<Void>() {
			@Override
			public Void run() throws Exception {
				runMethod(args);
				return null;
			}
		});
	}

	private void runMethod(String[] args) throws IllegalAccessException, InvocationTargetException,
			NoSuchMethodException {
		runningClass.getMethod(_runMethod, String[].class).invoke(null, new Object[] {args});
	}

	private void outputGeneratedProperties(Props outputProperties) {
		logger.info("Outputting generated properties to " + ProcessJob.JOB_OUTPUT_PROP_FILE);

		if (outputProperties == null) {
			logger.info("  no gend props");
			return;
		}
		for (String key : outputProperties.getKeySet()) {
			logger.info("  gend prop " + key + " value:" + outputProperties.get(key));
		}

		String outputFileStr = System.getenv(ProcessJob.JOB_OUTPUT_PROP_FILE);
		if (outputFileStr == null) {
			return;
		}

		Map<String, String> properties = new LinkedHashMap<String, String>();
		for (String key : outputProperties.getKeySet()) {
			properties.put(key, outputProperties.get(key));
		}

		Writer writer = null;
		try {
			writer = new BufferedWriter(new FileWriter(outputFileStr));
			JSONUtils.writePropsNoJarDependency(properties, writer);
		} catch (Exception e) {
			new RuntimeException("Unable to store output properties to: " + outputFileStr);
		} finally {
			if (writer != null) {
				try {
					writer.close();
				} catch (IOException e) {
				}
			}
		}
	}

	public void cancelJob() {
		if (isFinished) {
			return;
		}
		logger.info("Attempting to call cancel on this job");

		Method cancelMethod = null;

		try {
			cancelMethod = runningClass.getMethod(_cancelMethod);
		} catch (SecurityException e) {
		} catch (NoSuchMethodException e) {
		}

		if (cancelMethod != null)
			try {
				cancelMethod.invoke(null);
			} catch (Exception e) {
				if (logger != null) {
					logger.error("Cancel method failed! ", e);
				}
			}
		else {
			throw new RuntimeException("Job " + jobName + " does not have cancel method " + _cancelMethod);
		}
	}

	private static Class<?> getClass(String className) throws Exception {
		Class<?> runningClass = HadoopJavaJobRunnerMain.class.getClassLoader().loadClass(className);
		if (runningClass == null) {
			throw new Exception("Class " + className + " was not found. Cannot run job.");
		}
		return runningClass;
	}
	
	public boolean shouldProxy(Properties prop) {
		String shouldProxy = prop.getProperty(HadoopSecurityManager.ENABLE_PROXYING);
		return shouldProxy != null && shouldProxy.equals("true");
	}
}
