/*
 * Copyright 2012 LinkedIn Corp.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package azkaban.jobtype;

import azkaban.jobExecutor.ProcessJob;
import azkaban.utils.JSONUtils;
import azkaban.utils.Props;

import org.apache.log4j.ConsoleAppender;
import org.apache.log4j.Layout;
import org.apache.log4j.Logger;
import org.apache.log4j.PatternLayout;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Properties;

public class JavaJobRunnerMain {

	// This is the Job interface method to get the properties generated by the
	// job.
	public static final String GET_GENERATED_PROPERTIES_METHOD = "getJobGeneratedProperties";

	public static final String CANCEL_METHOD_PARAM = "method.cancel";
	public static final String RUN_METHOD_PARAM = "method.run";
	public static final String[] PROPS_CLASSES = new String[] { "azkaban.utils.Props", "azkaban.common.utils.Props" };

	protected static final Layout DEFAULT_LAYOUT = new PatternLayout("%p %m\n");

	protected final Logger logger = Logger.getRootLogger();
//	protected final Logger logger = Logger.getLogger(JavaJobRunnerMain.class);
	protected Properties prop = new Properties();

	protected String _runMethod;
	protected String _cancelMethod;
	protected String jobName;
	protected boolean isFinished = false;
	protected boolean runStaticMethod;
	
	protected Object _javaObject = null;
	protected Class<?> runningClass = null;
	public static final String JOB_CLASS = "job.class";

	public static void main(String[] args) throws Exception {
		@SuppressWarnings("unused")
		JavaJobRunnerMain wrapper = new JavaJobRunnerMain(args);
	}

	public JavaJobRunnerMain(String[] args) throws Exception {
		Runtime.getRuntime().addShutdownHook(new Thread() {
			public void run() {
				cancelJob();
			}
		});

		try {
			setup();
			logger.info("Running job " + jobName);
			
			String className = prop.getProperty(JOB_CLASS);
			if (className == null) {
				throw new Exception("Class name is not set.");
			}
			logger.info("Class name " + className);

			_cancelMethod = prop.getProperty(CANCEL_METHOD_PARAM, "cancel");
			_runMethod = prop.getProperty(RUN_METHOD_PARAM);
			if(_runMethod == null) {
				throw new Exception("run method must be specified!");
			}

			logger.info("Invoking method " + _runMethod);
			if(runStaticMethod == false) {
				_javaObject = getObject(jobName, className, prop, logger);
				runMethod(_javaObject, _runMethod);
			} else {
				runningClass = getClass(className);
				runMethod(runningClass, _runMethod, args);
			}

			isFinished = true;
			
			// Get the generated properties and store them to disk, to be read
			// by ProcessJob.
			try {
				Object outputGendProps;
				if(runStaticMethod == false) {
					final Method generatedPropertiesMethod = _javaObject.getClass().getMethod(
						GET_GENERATED_PROPERTIES_METHOD, new Class<?>[] {});
					outputGendProps = generatedPropertiesMethod.invoke(_javaObject, new Object[] {});
				} else {
					final Method generatedPropertiesMethod = runningClass.getMethod(
							GET_GENERATED_PROPERTIES_METHOD, new Class<?>[] {});
					outputGendProps = generatedPropertiesMethod.invoke(null, new Object[] {});
				}
				if(outputGendProps != null) {
					final Method toPropertiesMethod = outputGendProps.getClass().getMethod("toProperties", new Class<?>[] {});
					Properties properties = (Properties)toPropertiesMethod.invoke(outputGendProps, new Object[] {});
	
					Props outputProps = new Props(null, properties);
					outputGeneratedProperties(outputProps);
				}
				else {
					outputGeneratedProperties(new Props());
				}
				
			} 
      catch (NoSuchMethodException e) {
				logger.info(String.format(
						"Apparently there isn't a method[%s], using empty Props object instead.",
						GET_GENERATED_PROPERTIES_METHOD));
				outputGeneratedProperties(new Props());
			}
		} 
    catch (Exception e) {
			isFinished = true;
			throw e;
		}
	}

	protected void setup() throws Exception {
		
		logger.removeAllAppenders();
		ConsoleAppender appender = new ConsoleAppender(DEFAULT_LAYOUT);
		appender.activateOptions();
		logger.addAppender(appender);

		jobName = System.getenv(ProcessJob.JOB_NAME_ENV);
		
		String propsFile = System.getenv(ProcessJob.JOB_PROP_ENV);
		prop.load(new BufferedReader(new FileReader(propsFile)));
		runStaticMethod = Boolean.valueOf(prop.getProperty("run.static.method", "false"));
	}
	
	protected static Class<?> getClass(String className) throws Exception {
		Class<?> runningClass = HadoopJavaJobRunnerMain.class.getClassLoader().loadClass(className);
		if (runningClass == null) {
			throw new Exception("Class " + className + " was not found. Cannot run job.");
		}
		return runningClass;
	}

	private void runMethod(Object obj, String runMethod) throws IllegalAccessException, InvocationTargetException,
			NoSuchMethodException {
		obj.getClass().getMethod(runMethod, new Class<?>[] {}).invoke(obj);
	}

	private void runMethod(Class<?> runningClass, String methodName, String[] args) throws IllegalAccessException, InvocationTargetException,
		NoSuchMethodException {
		runningClass.getMethod(methodName, String[].class).invoke(null, new Object[] {args});
	}
	
	private void outputGeneratedProperties(Props outputProperties) {
		
		if (outputProperties == null) {
			logger.info("  no gend props");
			return;
		}
		for (String key : outputProperties.getKeySet()) {
			logger.info("  gend prop " + key + " value:" + outputProperties.get(key));
		}

		String outputFileStr = System.getenv(ProcessJob.JOB_OUTPUT_PROP_FILE);
		if (outputFileStr == null) {
			return;
		}
		
		logger.info("Outputting generated properties to " + outputFileStr);

		Map<String, String> properties = new LinkedHashMap<String, String>();
		for (String key : outputProperties.getKeySet()) {
			properties.put(key, outputProperties.get(key));
		}

		Writer writer = null;
		try {
			writer = new BufferedWriter(new FileWriter(outputFileStr));
			JSONUtils.writePropsNoJarDependency(properties, writer);
		} 
    catch (Exception e) {
			new RuntimeException("Unable to store output properties to: " + outputFileStr);
		} 
    finally {
			if (writer != null) {
				try {
					writer.close();
				} 
        catch (IOException e) {
				}
			}
		}
	}

	public void cancelJob() {
		if (isFinished) {
			return;
		}
		logger.info("Attempting to call cancel on this job");
		
		if(runStaticMethod == false) {
			if (_javaObject == null) {
				return;
			}
			Method method = null;
			try {
				method = _javaObject.getClass().getMethod(_cancelMethod);
			} 
		    catch (SecurityException e) {
		    } 
		    catch (NoSuchMethodException e) {
		    }
		
		    if (method != null) {
		      try {
		        method.invoke(_javaObject);
		      } 
		      catch (Exception e) {
		        if (logger != null) {
		          logger.error("Cancel method failed! ", e);
		        }
		      }
		    }
		    else {
		      throw new RuntimeException("Job " + jobName + " does not have cancel method " + _cancelMethod);
		    }
		} else {
			Method cancelMethod = null;

			try {
				cancelMethod = runningClass.getMethod(_cancelMethod);
			} catch (SecurityException e) {
			} catch (NoSuchMethodException e) {
			}

			if (cancelMethod != null)
				try {
					cancelMethod.invoke(null);
				} catch (Exception e) {
					if (logger != null) {
						logger.error("Cancel method failed! ", e);
					}
				}
			else {
				throw new RuntimeException("Job " + jobName + " does not have cancel method " + _cancelMethod);
			}
		}
	}

	private static Object getObject(String jobName, String className, Properties properties, Logger logger)
			throws Exception {

		Class<?> runningClass = JavaJobRunnerMain.class.getClassLoader().loadClass(className);

		if (runningClass == null) {
			throw new Exception("Class " + className + " was not found. Cannot run job.");
		}

		Class<?> propsClass = null;
		for (String propClassName : PROPS_CLASSES) {
			try {
				propsClass = JavaJobRunnerMain.class.getClassLoader().loadClass(propClassName);
			}
			catch (ClassNotFoundException e) {
			}
			
			if (propsClass != null && getConstructor(runningClass, String.class, propsClass) != null) {
				//is this the props class 
				break;
			}
			propsClass = null;
		}

		Object obj = null;
		if (propsClass != null && getConstructor(runningClass, String.class, propsClass) != null) {
			// Create props class
			Constructor<?> propsCon = getConstructor(propsClass, propsClass, Properties[].class);
			Object props = propsCon.newInstance(null, new Properties[] { properties });

			Constructor<?> con = getConstructor(runningClass, String.class, propsClass);
			logger.info("Constructor found " + con.toGenericString());
			obj = con.newInstance(jobName, props);
		} 
    else if (getConstructor(runningClass, String.class, Properties.class) != null) {
			Constructor<?> con = getConstructor(runningClass, String.class, Properties.class);
			logger.info("Constructor found " + con.toGenericString());
			obj = con.newInstance(jobName, properties);
		} 
    else if (getConstructor(runningClass, String.class, Map.class) != null) {
			Constructor<?> con = getConstructor(runningClass, String.class, Map.class);
			logger.info("Constructor found " + con.toGenericString());

			HashMap<Object, Object> map = new HashMap<Object, Object>();
			for (Map.Entry<Object, Object> entry : properties.entrySet()) {
				map.put(entry.getKey(), entry.getValue());
			}
			obj = con.newInstance(jobName, map);
		} 
    else if (getConstructor(runningClass, String.class) != null) {
			Constructor<?> con = getConstructor(runningClass, String.class);
			logger.info("Constructor found " + con.toGenericString());
			obj = con.newInstance(jobName);
		} 
    else if (getConstructor(runningClass) != null) {
			Constructor<?> con = getConstructor(runningClass);
			logger.info("Constructor found " + con.toGenericString());
			obj = con.newInstance();
		} 
    else {
			logger.error("Constructor not found. Listing available Constructors.");
			for (Constructor<?> c : runningClass.getConstructors()) {
				logger.info(c.toGenericString());
			}
		}
		return obj;
	}

	private static Constructor<?> getConstructor(Class<?> c, Class<?>... args) {
		try {
			Constructor<?> cons = c.getConstructor(args);
			return cons;
		}
    catch (NoSuchMethodException e) {
			return null;
		}
	}
}
